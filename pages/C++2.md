# class

```bash
拷贝构造函数
Box(const Box& B) {
    l = B.l;
    b = B.b;
    h = B.h;
}
// 拷贝构造函数里直接访问私有成员比用 getter 简洁

operator< 参数
bool operator<(const Box& B) const
// 比较两个 Box 不应该修改任何一个对象，而且要支持 const
```


```bash
const 参数:
bool operator<(const Box& B) const;

const Box& B
这里 B 是一个引用参数。
const 表示在函数体内部 不能修改 B。
好处：
避免误操作修改传入的对象。
可以支持用 const 对象 作为参数：
const Box b1(1,2,3);
Box b2(4,5,6);
bool res = b2 < b1; // ✅ b1 是 const，也能传进去

... ) const  // 成员函数结尾的 const
表示这个成员函数 不会修改当前对象 (this) 的成员变量
在函数内部，this 的类型会变成 const Box*，所以你不能改 l, b, h。

好处：
保证比较函数是“只读”的。
允许你对 const Box 对象 调用这个函数：
const Box b1(1,2,3), b2(4,5,6);
bool res = (b1 < b2);  // ✅ 因为 operator< 是 const 成员函数


综合解释:
比较操作不会修改参数 B（第一个 const）。
比较操作不会修改当前对象 this（第二个 const）。
也就是说，这个 < 运算符是一个只读函数，既不会改“自己”，也不会改“别人”。

```


```bash
在 C++ 里，类的成员函数（包括构造函数、拷贝构造函数、析构函数、普通成员函数）都对本类的对象有“特权访问权限”。

一个类的成员函数，不仅能访问当前对象的私有成员(this->l)，
也能访问 同类的其他对象的私有成员。

class Box {
private:
    int l, b, h;

public:
    Box(int length, int breadth, int height) : l(length), b(breadth), h(height) {}

    // 拷贝构造函数
    Box(const Box& B) {
        // 这里虽然 B 是另一个对象，但因为它和 this 是同一个类，
        // 所以可以直接访问它的私有成员
        l = B.l;
        b = B.b;
        h = B.h;
    }

    void copyFrom(const Box& other) {
        // 普通成员函数里，也能直接访问 other 的私有成员
        l = other.l;
        b = other.b;
        h = other.h;
    }
};


访问控制是按类(class)级别，而不是按对象(instance)级别。
private 意味着“只能被这个类的成员函数访问”。

不管是访问 当前对象的私有变量，还是 同类对象的私有变量，只要在类的成员函数里，都算合法。


 `private / protected / public` 在类、对象、派生类之间的可见性。

---

## C++ 访问控制示意图

```
                ┌───────────────────────────────┐
                │            class A            │
                ├──────────────┬────────────────┤
                │   private     │  仅 A 的成员函数 │
                │   protected   │  A 及其子类成员 │
                │   public      │  任何地方都可访问 │
                └──────────────┴────────────────┘
                           │
                           │
          ┌────────────────┴─────────────────┐
          │                                  │
     同一个类的对象                  派生类 class B : public A
          │                                  │
   ┌──────┴───────┐                  ┌───────┴────────┐
   │              │                  │                │
   │ 可以访问 A 的     │              │ 可以访问 A 的   │
   │ private 成员      │              │ protected 成员  │
   │ (因为在 A 的成员函数里) │         │ (不能访问 A 的 private)│
   │                 │                │                │
   │ 外部函数/非友元  │                │    外部函数/非友元 │
   │ ────────────────┘                └────────────────┘
    只能访问 public 成员                只能访问 public 成员
```
```
---

### 解释：

1. **private**

   * 只能在 **类 A 自己的成员函数** 内访问。
   * 包括访问 **this 对象** 和 **其他 A 对象** 的 private 成员。

2. **protected**

   * 和 private 类似，但允许 **子类（派生类）** 访问。
   * 子类依然不能访问基类对象的 private 成员。

3. **public**

   * 任何地方都能访问（包括外部函数、main 等）。

---

### 举个代码例子

```cpp
class A {
private:
    int x;
protected:
    int y;
public:
    int z;

    void copyFrom(const A& other) {
        x = other.x;  // ✅ 可以访问同类对象的 private
        y = other.y;  // ✅ 可以访问同类对象的 protected
        z = other.z;  // ✅ 可以访问同类对象的 public
    }
};

class B : public A {
public:
    void test() {
        // x = 10;   ❌ 子类不能访问基类的 private
        y = 20;      // ✅ 子类可以访问基类的 protected
        z = 30;      // ✅ 子类可以访问基类的 public
    }
};

int main() {
    A a;
    // a.x = 1;    ❌ 外部无法访问 private
    // a.y = 2;    ❌ 外部无法访问 protected
    a.z = 3;       // ✅ 外部可以访问 public
}

```


```bash
friend ostream& operator<<(ostream& out, const Box& B) { out << B.l << " " << B.b << " " << B.h; return out; }

operator<< 是一个全局运算符重载（不是成员函数）。

它的第一个参数必须是 ostream&（比如 std::cout）。

如果写成成员函数，就变成 cout.operator<<(box)，这不直观。

所以我们通常把 operator<< 写成非成员函数，并加 friend，这样它可以直接访问类的私有成员。

👉 没有 friend 的话，就只能通过 getLength() 等 getter 来访问。


为什么返回 ostream&
return out;

这样可以支持 连续输出：
cout << box1 << box2 << box3;

如果不返回 ostream&，链式调用就不成立。
std::ostream 本身的 operator<< 也是这样设计的。


为什么 const Box& B
friend ostream& operator<<(ostream& out, const Box& B)
const：保证输出的时候不会修改 Box。
&：避免拷贝整个对象，提高效率。

friend：允许访问私有成员。
ostream&：保证链式输出。
const Box&：高效、只读。



1. operator< 需要比较两个对象
语法上你希望写：
if (box1 < box2) { ... }

如果是成员函数：
bool operator<(const Box& other) const;
那么等价于：
box1.operator<(box2);

很自然，左操作数 (box1) 是 this 对象，右操作数 (box2) 是参数。
这种情况正好符合 < 的语义：用 box1 去比较 box2。
所以写成成员函数就很方便。


operator<< 的左操作数是 ostream（cout）。
你没办法把它写成 ostream 的成员函数（你不能去改标准库 ostream）。
所以必须写成非成员函数，而为了访问 Box 的私有成员，就需要加 friend。
```