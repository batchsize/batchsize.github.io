
```bash
编译opencv
cv::getBuildInformation() 查看opencv 编译是否支持ffmpeg
git clone --branch 2.4 --depth 1 https://github.com/opencv/opencv.git

编译ffpmeg
git clone --branch release/4.3 --depth 1 https://github.com/FFmpeg/FFmpeg.git


编译h264
git clone https://code.videolan.org/videolan/x264.git
```
build_x264.sh
```bash
#!/bin/bash
 
# 设置工具链路径
TOOLCHAIN_PATH=/root/tools/toolchains/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf
GCC_COMPILER=${TOOLCHAIN_PATH}/bin/arm-linux-gnueabihf
 
# 设置x264安装路径
X264_INSTALL_DIR=/root/tools/3rdparty/install/x264
 
 
 
# 配置交叉编译选项，直接指定 C 和 C++ 编译器
./configure --prefix=${X264_INSTALL_DIR} \
            --cross-prefix=${GCC_COMPILER}- \
            --cc=${GCC_COMPILER}-gcc \
            --cxx=${GCC_COMPILER}-g++ \
            --host=arm-linux \
            --enable-cross-compile \
            --enable-shared \
            --disable-static \
            --enable-pic \
            --extra-cflags="-g -I${TOOLCHAIN_PATH}/include" \
            --extra-ldflags="-L${TOOLCHAIN_PATH}/lib"
 
 
# 编译并安装x264
make -j$(nproc)
make install
```
 

build_ffmpeg.sh
```bash
#!/bin/bash
 
# 设置工具链路径
TOOLCHAIN_PATH=/root/tools/toolchains/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf
GCC_COMPILER=${TOOLCHAIN_PATH}/bin/arm-linux-gnueabihf
X264_INSTALL_DIR=/root/tools/3rdparty/install/x264
# 设置FFmpeg安装路径
FFMPEG_INSTALL_DIR=/root/tools/3rdparty/install/ffmpeg
 
 
# 配置交叉编译选项，直接指定 C 和 C++ 编译器
./configure --prefix=${FFMPEG_INSTALL_DIR} \
            --cc=${GCC_COMPILER}-gcc \
            --cxx=${GCC_COMPILER}-g++ \
            --target-os=linux \
            --arch=arm \
            --enable-cross-compile \
            --enable-shared \
            --disable-static \
            --disable-debug \
            --disable-doc \
            --enable-gpl \
            --enable-libx264 \
            --enable-pic \
            --extra-cflags="-I${X264_INSTALL_DIR}/include -I${TOOLCHAIN_PATH}/include" \
            --extra-ldflags="-L${X264_INSTALL_DIR}/lib -L${TOOLCHAIN_PATH}/lib" \
            --strip=${GCC_COMPILER}-strip
 
# 编译并安装FFmpeg
make -j$(nproc)
make install
 
# 清理
# cd ..
# rm -rf ffmpeg-${FFMPEG_VERSION}
# rm ffmpeg-${FFMPEG_VERSION}.tar.bz2
 
echo "FFmpeg has been installed in ${FFMPEG_INSTALL_DIR}"
报错libavcodec/libx264.c:282:9: error: ‘x264_bit_depth’ undeclared
解决:替换x264_bit_depth为 X264_BIT_DEPTH 0 编译通过
```

opencv_build.sh
```bash
#!/bin/bash
 
set -e
 
# 设置工具链路径
export TOOLCHAIN_PATH=/root/tools/toolchains/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf
export GCC_COMPILER=${TOOLCHAIN_PATH}/bin/arm-linux-gnueabihf
 
 
# 清理并创建构建目录
rm -rf build
mkdir build
cd build
# 备份原始路径
export ORIGINAL_LD_LIBRARY_PATH=$LD_LIBRARY_PATH
export ORIGINAL_PATH=$PATH
 
# 临时移除Anaconda路径
export LD_LIBRARY_PATH=$(echo $LD_LIBRARY_PATH | tr ':' '\n' | grep -v 'anaconda' | tr '\n' ':' | sed 's/:$//')
export PATH=$(echo $PATH | tr ':' '\n' | grep -v 'anaconda' | tr '\n' ':' | sed 's/:$//')
 
 
export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/root/tools/3rdparty/install/ffmpeg/lib/pkgconfig
 
# 配置交叉编译选项
cmake -DCMAKE_BUILD_TYPE=RELEASE \
      -DCMAKE_SYSTEM_NAME=Linux \
      -DCMAKE_SYSTEM_PROCESSOR=arm \
      -DCMAKE_C_COMPILER=${GCC_COMPILER}-gcc \
      -DCMAKE_CXX_COMPILER=${GCC_COMPILER}-g++ \
      -DCMAKE_FIND_ROOT_PATH=${TOOLCHAIN_PATH} \
      -DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER \
      -DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=ONLY \
      -DCMAKE_FIND_ROOT_PATH_MODE_INCLUDE=ONLY \
      -DBUILD_SHARED_LIBS=ON \
      -DWITH_FFMPEG=ON \
      -DFFMPEG_INCLUDE_DIRS=/root/tools/3rdparty/install/ffmpeg/include \
      -DWITH_1394=OFF \
      -DWITH_GTK=OFF \
      -DWITH_FREETYPE=OFF \
      -DWITH_HARFBUZZ=OFF \
      -DBUILD_opencv_freetype=OFF \
      -DBUILD_opencv_highgui=OFF \
      -DCMAKE_INSTALL_PREFIX=/root/tools/3rdparty/install/opencv2.4 \
      ../
 
# 检查是否生成了Makefile
if [ ! -f "Makefile" ]; then
  echo "CMake configuration failed. Makefile not found."
  exit 1
fi
 
# 构建和安装
make -j$(nproc) 2>&1 | tee make_output.log
if [ $? -ne 0 ]; then
  echo "Make failed. Check make_output.log for details."
  exit 1
fi
 
make install 2>&1 | tee make_install_output.log
if [ $? -ne 0 ]; then
  echo "Make install failed. Check make_install_output.log for details."
  exit 1
fi
 
# echo "OpenCV has been successfully built and installed with FFmpeg and x264 support."
# 还原LD_LIBRARY_PATH和PATH
export LD_LIBRARY_PATH=$ORIGINAL_LD_LIBRARY_PATH
export PATH=$ORIGINAL_PATH


cmake -DCMAKE_BUILD_TYPE=RELEASE       -DCMAKE_SYSTEM_NAME=Linux       -DCMAKE_SYSTEM_PROCESSOR=arm       -DCMAKE_C_COMPILER=${GCC_COMPILER}-gcc       -DCMAKE_CXX_COMPILER=${GCC_COMPILER}-g++       -DCMAKE_FIND_ROOT_PATH=${TOOLCHAIN_PATH}       -DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER       -DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=ONLY       -DCMAKE_FIND_ROOT_PATH_MODE_INCLUDE=ONLY       -DBUILD_SHARED_LIBS=ON       -DWITH_FFMPEG=ON       -DFFMPEG_INCLUDE_DIRS=/root/tools/3rdparty/install/ffmpeg/include       -DWITH_1394=OFF       -DWITH_GTK=OFF       -DBUILD_opencv_ml=OFF       -DCMAKE_INSTALL_PREFIX=/root/tools/3rdparty/install/opencv_new  -DFFMPEG_DIR= /root/tools/3rdparty/install/ffmpeg -DCMAKE_LIBRARY_PATH=/root/tools/3rdparty/install/ffmpeg/lib  -DCMAKE_INCLUDE_PATH=/root/tools/3rdparty/install/ffmpeg/include   -DWITH_FREETYPE=OFF -DWITH_HARFBUZZ=OFF -DBUILD_opencv_freetype=OFF -D WITH_OPENCL=OFF  ..
```


 CPACK_PACKAGE_VERSION does not match version provided by version.hpp
在opencv-2.4.13.6\modules\core\include\opencv2\core打开version.hpp文件
然后在opencv-2.4.13.6\cmake文件夹下打开OpenCVPackaging.cmake文件并添加以下代码set(OPENCV_VCSVERSION "2.4.13.6")，此处根据实际情况修改OpenCV版本号，然后CMake编译通过！！


DMA (Direct Memory Access) 内存 是一种允许外设（例如硬盘、网络适配器、音频/视频设备等）直接访问系统内存（RAM）而不经过 CPU 的技术。通过 DMA，外设可以直接将数据读写到内存中，从而减少 CPU 的负担，提高数据传输效率。


```bash
要交叉编译 FFmpeg 在 ARM 架构上并且支持 H.264 编解码，你需要进行一系列步骤，包括准备交叉编译工具链、下载 FFmpeg 源码、配置编译选项并确保启用 H.264 编解码支持。以下是详细的步骤。
# 前提条件：
- 交叉编译工具链：你需要使用针对 ARM 架构的交叉编译器。例如，使用 arm-linux-gnueabihf-gcc 工具链。
- 支持 H.264 编解码：H.264 编解码依赖于 x264 库，它是 FFmpeg 支持 H.264 的常用库。
# 步骤 1：准备交叉编译环境
1. 安装交叉编译工具链 如果你没有安装交叉编译工具链，可以通过以下命令安装它：
sudo apt-get update
sudo apt-get install gcc-arm-linux-gnueabihf
1. 确保你安装了适合 ARM 目标架构的交叉编译工具链。
2. 安装其他必要的工具： 安装交叉编译所需的工具和依赖项：
sudo apt-get install make pkg-config yasm
# 步骤 2：获取 FFmpeg 源码
你可以从 FFmpeg 官方 Git 仓库克隆最新的源代码，也可以直接下载稳定的版本。
1. 克隆 FFmpeg 源代码：
git clone https://github.com/FFmpeg/FFmpeg.git
cd FFmpeg
1. 或者，下载 FFmpeg 的发布版本： 访问 FFmpeg Releases 页面，选择适合的版本并下载。
# 步骤 3：交叉编译 x264（用于 H.264 编解码）
FFmpeg 支持 H.264 编解码的功能通常需要依赖于 x264 库。因此，我们需要交叉编译 x264 库并让 FFmpeg 使用它。
1. 获取 x264 源代码： 你可以从 x264 的官方网站或 Git 仓库下载源码。
git clone https://code.videolan.org/videolan/x264.git
cd x264
1. 配置和编译 x264： 在配置 x264 时，你需要指定交叉编译工具链的路径。
./configure --host=arm-linux --prefix=/path/to/installation/directory --enable-shared
make -j$(nproc)
make install
  - --prefix 选项指定安装路径，通常选择一个合适的目录，如 /path/to/installation/directory。
  - --enable-shared 选项启用共享库，以便 FFmpeg 使用。
# 步骤 4：交叉编译 FFmpeg
1. 进入 FFmpeg 源码目录：
cd FFmpeg
1. 配置编译选项： 使用交叉编译工具链配置 FFmpeg。在配置过程中，我们需要告诉 FFmpeg 使用交叉编译工具链，并启用对 H.264 的支持（即使用 x264 库）。
./configure \
    --prefix=/path/to/installation/directory \
    --cross-prefix=arm-linux-gnueabihf- \
    --arch=arm \
    --target-os=linux \
    --enable-cross-compile \
    --enable-shared \
    --enable-gpl \
    --enable-libx264 \
    --disable-debug \
    --disable-doc \
    --enable-pic
1. 主要参数：
  - --prefix：指定安装目录。
  - --cross-prefix：指定交叉编译工具链的前缀（根据你的工具链修改）。
  - --arch=arm：目标架构是 ARM。
  - --target-os=linux：目标操作系统是 Linux。
  - --enable-libx264：启用对 x264 的支持（即 H.264 编解码）。
  - --enable-shared：启用共享库。
  - --disable-debug：禁用调试信息，通常可以加速编译过程。
2. 编译 FFmpeg： 配置完成后，执行以下命令来编译 FFmpeg。
make -j$(nproc)
1. -j$(nproc) 会根据你机器的处理器核心数来并行编译，提升编译速度。
2. 安装 FFmpeg： 编译完成后，安装 FFmpeg。
make install
# 步骤 5：验证 FFmpeg 是否支持 H.264
安装完成后，你可以在 ARM 设备上运行 FFmpeg 并检查是否支持 H.264 编解码。
ffmpeg -codecs | grep h264
如果输出中有 h264 编解码器，表示 H.264 支持已经成功启用。
# 小结：
- 你需要使用交叉编译工具链（如 arm-linux-gnueabihf-）来编译 FFmpeg 和 x264。
- 配置 FFmpeg 和 x264 时，确保启用 H.264 支持（使用 --enable-libx264）。
- 编译时使用适当的交叉编译选项，确保最终可在 ARM 设备上运行。
```


# cmake 编译opencv
```bash

cmake -DCMAKE_BUILD_TYPE=Release \
      -DCMAKE_INSTALL_PREFIX=./install \
      -DWITH_CUDA=OFF \
      -DWITH_OPENCL=OFF \
      -DWITH_IPP=OFF \
      -DWITH_TBB=OFF \
      -DBUILD_opencv_python3=OFF \
      -DBUILD_opencv_python2=OFF \
      -DBUILD_opencv_java=OFF \
      -DBUILD_opencv_xfeatures2d=OFF \
      -DBUILD_opencv_cudafeatures2d=OFF \
      -DBUILD_opencv_cudaarithm=OFF \
      -DBUILD_opencv_cudawarping=OFF \
      -DBUILD_opencv_cudabgsegm=OFF \
      -DBUILD_opencv_cudaoptflow=OFF \
      -DBUILD_opencv_stitching=ON \
      -DOPENCV_EXTRA_MODULES_PATH=../../opencv_contrib/modules ..

```

# sdk
```bash


```



```
# 交叉编译aarch64

cmake \
-DCMAKE_SYSTEM_NAME=Linux \
-DCMAKE_SYSTEM_PROCESSOR=aarch64 \
-DCMAKE_C_COMPILER=/home/work/tools/toolchain/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-gcc \
-DCMAKE_CXX_COMPILER=/home/work/tools/toolchain/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-g++ \
-DCMAKE_FIND_ROOT_PATH=/home/work/tools/toolchain/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu \
-DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER \
-DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=ONLY \
-DCMAKE_FIND_ROOT_PATH_MODE_INCLUDE=ONLY \
-DBUILD_opencv_gpu=OFF \
-DBUILD_SHARED_LIBS=ON \
-DWITH_GTK=OFF \
-DWITH_JPEG=ON \
-DWITH_PNG=ON \
-DWITH_TIFF=ON \
-DWITH_JASPER=ON \
-DWITH_OPENEXR=OFF \
-DWITH_TBB=OFF \
-DWITH_1394=OFF \
-DWITH_FFMPEG=OFF \
-DWITH_GSTREAMER=OFF \
-DBUILD_TESTS=OFF \
-DBUILD_PERF_TESTS=OFF \
-DBUILD_EXAMPLES=OFF \
-DBUILD_DOCS=OFF \
-DBUILD_opencv_apps=OFF \
-DBUILD_opencv_calib3d=ON \
-DBUILD_opencv_contrib=OFF \
-DBUILD_opencv_core=ON \
-DBUILD_opencv_features2d=ON \
-DBUILD_opencv_flann=ON \
-DBUILD_opencv_highgui=OFF \
-DBUILD_opencv_imgproc=ON \
-DBUILD_opencv_legacy=OFF \
-DBUILD_opencv_ml=ON \
-DBUILD_opencv_objdetect=ON \
-DBUILD_opencv_video=ON \
-DCMAKE_INSTALL_PREFIX=./install \
..

```



### zmq 编译

```
wget https://github.com/zeromq/libzmq/releases/download/v4.3.4/zeromq-4.3.4.tar.gz
tar -xzf zeromq-4.3.4.tar.gz
cd zeromq-4.3.4

# 工具链前缀（不含 -gcc）
export TOOLCHAIN_DIR=/home/work/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin
export CROSS_PREFIX=${TOOLCHAIN_DIR}/aarch64-none-linux-gnu

export CC=${CROSS_PREFIX}-gcc
export CXX=${CROSS_PREFIX}-g++
export LD=${CROSS_PREFIX}-ld
export AR=${CROSS_PREFIX}-ar
export AS=${CROSS_PREFIX}-as
export STRIP=${CROSS_PREFIX}-strip
export RANLIB=${CROSS_PREFIX}-ranlib

# 生成 configure 脚本
./autogen.sh

./configure \
  --host=aarch64-none-linux-gnu \
  --prefix=$(pwd)/install \
  --enable-shared \
  --disable-static

make -j$(nproc)
make install

file install/lib/libzmq.so.5  // libzmq.so.5: ELF 64-bit LSB shared object, ARM aarch64, ...

$STRIP install/lib/libzmq.so.5

cp libzmq.so.5.2.4 libzmq.so.5 // 只保留libzmq.so.5

打包脚本
#!/bin/bash

# 设置路径（你自己的 ZeroMQ 安装目录）
INSTALL_DIR=$(pwd)/install
OUTPUT_TAR=zeromq-4.3.4-arm64.tar.gz

# 检查必要文件是否存在
if [ ! -f "$INSTALL_DIR/lib/libzmq.so.5.2.4" ]; then
  echo "Error: libzmq.so.5.2.4 not found in $INSTALL_DIR/lib"
  exit 1
fi

# 创建打包临时目录
PKG_DIR=zeromq-arm64-package
rm -rf $PKG_DIR
mkdir -p $PKG_DIR/lib
mkdir -p $PKG_DIR/include

# 拷贝并重命名库文件
cp $INSTALL_DIR/lib/libzmq.so.5.2.4 $PKG_DIR/lib/libzmq.so.5

# 可选：strip 精简库体积（根据你的工具链修改路径）
STRIP_TOOL=/home/work/tools/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-strip
$STRIP_TOOL $PKG_DIR/lib/libzmq.so.5

# 拷贝头文件
cp -r $INSTALL_DIR/include/zmq $PKG_DIR/include/

# 打包为 .tar.gz
tar -czf $OUTPUT_TAR -C $PKG_DIR .

# 清理临时目录
rm -rf $PKG_DIR

echo "✅ 打包完成: $OUTPUT_TAR"



zmq.hpp 是 ZeroMQ 的 C++ 绑定头文件，但它 不是 ZeroMQ 源码的一部分，因此 不会随着 libzmq 的交叉编译自动生成或安装。

wget https://raw.githubusercontent.com/zeromq/cppzmq/master/zmq.hpp -O zmq.hpp
cp zmq.hpp /path/to/libzmq/install/include/
```


### yaml

```
git clone https://github.com/jbeder/yaml-cpp.git
cd yaml-cpp
git checkout yaml-cpp-0.7.0


# toolchains/rv1126-aarch64.cmake

# 1. 指定系统平台
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR aarch64)

# 2. 指定交叉编译工具链前缀
set(TOOLCHAIN_PATH "/home/work/tools/rv1126b/RV1126B-SDK/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu")
set(CROSS_COMPILE "${TOOLCHAIN_PATH}/bin/aarch64-none-linux-gnu")

# 3. 设置 C/C++ 编译器
set(CMAKE_C_COMPILER ${CROSS_COMPILE}-gcc)
set(CMAKE_CXX_COMPILER ${CROSS_COMPILE}-g++)

# 4. 设置安装前缀路径（你可以按需修改）
set(CMAKE_INSTALL_PREFIX "${CMAKE_CURRENT_LIST_DIR}/../build-aarch64/install" CACHE PATH "Installation path" FORCE)

# 5. 优先搜索目标平台的头文件和库（而非宿主）
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)



cmake .. \
  -DCMAKE_TOOLCHAIN_FILE=../toolchains/rv1126-aarch64.cmake \
  -DCMAKE_INSTALL_PREFIX=$(pwd)/install \
  -DBUILD_SHARED_LIBS=ON \
  -DYAML_CPP_BUILD_TESTS=OFF
(
或# 添加这一行到 toolchains/rv1126-aarch64.cmake
set(CMAKE_INSTALL_PREFIX "${CMAKE_CURRENT_LIST_DIR}/../build-aarch64/install" CACHE PATH "Installation path" FORCE)
)

打包脚本

#!/bin/bash
cd "$(dirname "$0")"

PKG_NAME="yaml-cpp-0.7.0-arm64"
INSTALL_DIR="./install"
STRIP_TOOL="/home/work/tools/rv1126b/RV1126B-SDK/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-strip"

# Strip .so
$STRIP_TOOL $INSTALL_DIR/lib/libyaml-cpp.so.0.7

# 生成压缩包
tar -czf ${PKG_NAME}.tar.gz -C $INSTALL_DIR .

echo "✅ 打包完成: ${PKG_NAME}.tar.gz"


```


### 编译 libcrypto.so.1.1

```
wget https://www.openssl.org/source/openssl-1.1.1w.tar.gz
tar -xf openssl-1.1.1w.tar.gz

make clean
make distclean

export TOOLCHAIN_PATH=/home/work/tools/rv1126b/RV1126B-SDK/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu
export PATH=$TOOLCHAIN_PATH/bin:$PATH
export CROSS_COMPILE=aarch64-none-linux-gnu-

which ${CROSS_COMPILE}gcc


./Configure linux-aarch64 \
  --cross-compile-prefix=${CROSS_COMPILE} \
  --prefix=$(pwd)/install \
  no-tests no-ssl2 no-ssl3 no-comp no-hw no-engine

make -j$(nproc)
make install_sw
```


```
🔧 make clean
删除 大部分 编译中间文件，例如：

.o 目标文件

.lo、.la 等临时链接文件

部分中间库

不会删除你配置生成的文件（如 Makefile）

✅ 用于：轻量清理、重新编译

🔥 make distclean
删除 所有 编译生成文件和配置结果，包括：

make clean 删除的内容

Makefile

configdata.pm

include/openssl/opensslconf.h 等自动生成头文件

会让你恢复到最初解压源码后的状态

✅ 用于：彻底清理、准备重新配置（如 ./Configure 改错）

🧠 总结对比：
命令	删除中间文件	删除配置文件	适用场景
make clean	✅	❌	修改源码后重新编译
make distclean	✅	✅	修改交叉编译参数/路径/配置后重新开始

```


## libcurl
```
wget https://curl.se/download/curl-7.79.1.tar.gz
tar xf curl-7.79.1.tar.gz

export TOOLCHAIN=/home/work/tools/rv1126b/RV1126B-SDK/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu

export CROSS_PREFIX=aarch64-none-linux-gnu
export SYSROOT=$TOOLCHAIN/aarch64-none-linux-gnu/libc

export CC=$TOOLCHAIN/bin/${CROSS_PREFIX}-gcc
export CXX=$TOOLCHAIN/bin/${CROSS_PREFIX}-g++
export AR=$TOOLCHAIN/bin/${CROSS_PREFIX}-ar
export RANLIB=$TOOLCHAIN/bin/${CROSS_PREFIX}-ranlib
export LD=$TOOLCHAIN/bin/${CROSS_PREFIX}-ld
export STRIP=$TOOLCHAIN/bin/${CROSS_PREFIX}-strip


./configure \
    --host=aarch64-none-linux-gnu \
    --with-sysroot=$SYSROOT \
    --prefix=$(pwd)/install \
    --disable-shared \
    --enable-static \
    --with-ssl=/home/work/tools/rv1126b/tool_rv1126b/openssl-1.1.1w/install \
    CFLAGS="-fPIC" CXXFLAGS="-fPIC" \
    CC=$CC

make -j$(nproc)
make install

--host	指定交叉编译目标架构
--with-sysroot	使用 sysroot 根路径
--prefix	安装路径
--with-ssl=PATH	指定交叉编译好的 OpenSSL 路径
--enable-shared	构建动态库 .so
--disable-shared	构建静态库 .a（二选一）

```


# 交叉编译 protobuf-2.6.1

```
1. 先编译一个 native(x86) 版本protoc

cd protobuf-2.6.1
make distclean   # 确保干净
./configure --prefix=$PWD/host_build
make -j$(nproc)
make install


2. 交叉编译

make distclean
export TOOLCHAIN=/root/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin

export CC=$TOOLCHAIN/aarch64-none-linux-gnu-gcc
export CXX=$TOOLCHAIN/aarch64-none-linux-gnu-g++
export AR=$TOOLCHAIN/aarch64-none-linux-gnu-ar
export LD=$TOOLCHAIN/aarch64-none-linux-gnu-ld
export RANLIB=$TOOLCHAIN/aarch64-none-linux-gnu-ranlib
export STRIP=$TOOLCHAIN/aarch64-none-linux-gnu-strip

./configure --host=aarch64-none-linux-gnu --prefix=$PWD/aarch64_install \
    --with-protoc=$PWD/host_build/bin/protoc  \
    CFLAGS="-fPIC" CXXFLAGS="-fPIC"
make -j$(nproc)
make install



```