åœ¨ C++ ä¸­ï¼Œ**æ®µé”™è¯¯ï¼ˆSegmentation Fault / SIGSEGVï¼‰æ˜¯æ“ä½œç³»ç»Ÿå‘å‡ºçš„ä¿¡å·**ï¼Œè¡¨ç¤ºç¨‹åºè®¿é—®äº†æœªè¢«å…è®¸çš„å†…å­˜åŒºåŸŸï¼Œæ¯”å¦‚è®¿é—®ç©ºæŒ‡é’ˆæˆ–éæ³•å†…å­˜ã€‚å®ƒä¸æ˜¯ C++ çš„å¼‚å¸¸ï¼ˆå¦‚ `try-catch` èƒ½æ•è·çš„ `std::exception`ï¼‰ï¼Œå› æ­¤ä¸èƒ½ç”¨ `try-catch` æ•è·ã€‚

ä½†ä½ å¯ä»¥é€šè¿‡ **ä¿¡å·å¤„ç†æœºåˆ¶ (`signal`)** æˆ–æ›´é«˜çº§çš„ **`sigaction`** æ¥æ•è·æ®µé”™è¯¯ï¼Œæ‰§è¡Œä¸€äº›æ¸…ç†æˆ–æ—¥å¿—æ“ä½œï¼Œç„¶åå†³å®šæ˜¯å¦ç»ˆæ­¢ç¨‹åºã€‚ä¸‹é¢æ˜¯ä¸€äº›å¸¸è§æ–¹æ³•ï¼š

---

### âœ… æ–¹æ³•ä¸€ï¼šä½¿ç”¨ `signal()` æ•è· SIGSEGV

```cpp
#include <iostream>
#include <csignal>
#include <cstdlib>

void signalHandler(int signum) {
    std::cerr << "Caught signal " << signum << " (Segmentation Fault)" << std::endl;
    // å¯ä»¥åšä¸€äº›æ¸…ç†æ“ä½œï¼Œå¦‚æ—¥å¿—è®°å½•ã€èµ„æºé‡Šæ”¾ç­‰
    exit(signum);  // æˆ– std::exit(signum)
}

int main() {
    std::signal(SIGSEGV, signalHandler);

    // æ•…æ„åˆ¶é€ æ®µé”™è¯¯
    int* ptr = nullptr;
    *ptr = 42;  // æ®µé”™è¯¯

    return 0;
}
```

---

### âœ… æ–¹æ³•äºŒï¼šä½¿ç”¨ `sigaction()`ï¼ˆæ›´æ¨èï¼ŒåŠŸèƒ½æ›´å¼ºå¤§ï¼‰

```cpp
#include <iostream>
#include <csignal>
#include <cstdlib>
#include <cstring>
#include <unistd.h>

void segfaultHandler(int signum, siginfo_t* info, void* context) {
    std::cerr << "Caught signal " << signum << " (Segmentation Fault)" << std::endl;
    std::cerr << "Fault address: " << info->si_addr << std::endl;

    _exit(signum);  // ä½¿ç”¨ _exit é¿å…åœ¨å¼‚å¸¸æ ˆä¸­ç ´åæ›´å¤šçŠ¶æ€
}

int main() {
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_sigaction = segfaultHandler;
    sa.sa_flags = SA_SIGINFO;

    sigaction(SIGSEGV, &sa, nullptr);

    // æ•…æ„åˆ¶é€ æ®µé”™è¯¯
    int* p = nullptr;
    *p = 10;

    return 0;
}
```

---

### ğŸš« ä¸èƒ½ç”¨ `try-catch` æ•è·æ®µé”™è¯¯

```cpp
try {
    int* p = nullptr;
    *p = 42; // æ®µé”™è¯¯
} catch (...) {
    std::cerr << "Caught exception" << std::endl; // âš ï¸ ä¸ä¼šæ•è·æ®µé”™è¯¯
}
```

è¿™ç§æ–¹å¼ **æ— æ³•æ•è·** æ®µé”™è¯¯ï¼Œå› ä¸ºæ®µé”™è¯¯ä¸æ˜¯ C++ å¼‚å¸¸ã€‚

---

### ğŸ”’ æ³¨æ„äº‹é¡¹

1. **æ®µé”™è¯¯å¾€å¾€è¯´æ˜ç¨‹åºé€»è¾‘æœ‰ bug**ï¼Œæ•è·åªæ˜¯ä¸ºäº†è®°å½•æˆ–å‹å¥½é€€å‡ºï¼Œä¸èƒ½è®©ç¨‹åºâ€œæ— ä¼¤ç»§ç»­â€è¿è¡Œã€‚
2. å¦‚æœä½ å¸Œæœ›ç¨‹åºåœ¨è°ƒè¯•æ—¶å´©æºƒï¼ˆç”¨äºç”Ÿæˆ core dumpï¼‰ï¼Œå¯ä»¥ä¸æ•è·å®ƒã€‚
3. åœ¨ç”Ÿäº§ç³»ç»Ÿä¸­ï¼Œå»ºè®®è®°å½•æ—¥å¿—ã€è¾“å‡º backtraceï¼ˆå¦‚ç”¨ `backtrace()`ï¼‰åé€€å‡ºã€‚

---

### ğŸ§  è¡¥å……ï¼šæ‰“å° backtraceï¼ˆè°ƒè¯•ç”¨é€”ï¼‰

```cpp
#include <execinfo.h>  // backtrace
void segfaultHandler(int signum) {
    void* array[10];
    size_t size = backtrace(array, 10);
    backtrace_symbols_fd(array, size, STDERR_FILENO);
    exit(signum);
}
```

---

éœ€è¦æˆ‘å¸®ä½ é›†æˆä¸€ä¸ªå®Œæ•´çš„æ•è· + æ—¥å¿— + backtrace ç¤ºä¾‹å—ï¼Ÿ


å¥½çš„ï¼Œä»¥ä¸‹æ˜¯ä¸€ä¸ª**å®Œæ•´çš„ C++ ç¤ºä¾‹**ï¼Œç”¨äºæ•è·æ®µé”™è¯¯ï¼ˆSIGSEGVï¼‰ã€æ‰“å°é”™è¯¯ä¿¡æ¯å’Œå‡½æ•°è°ƒç”¨æ ˆï¼ˆbacktraceï¼‰ï¼Œç„¶åä¼˜é›…é€€å‡ºç¨‹åºã€‚

---

## âœ… å®Œæ•´ç¤ºä¾‹ä»£ç ï¼šæ•è·æ®µé”™è¯¯ + æ‰“å° backtrace

```cpp
#include <iostream>
#include <csignal>
#include <cstdlib>
#include <execinfo.h>   // for backtrace
#include <unistd.h>     // for STDERR_FILENO
#include <cstring>      // for memset

void segfaultHandler(int signum, siginfo_t* info, void* context) {
    std::cerr << "==========================================" << std::endl;
    std::cerr << "ğŸ’¥ Caught signal " << signum << " (Segmentation Fault)" << std::endl;
    std::cerr << "ğŸ§  Fault address: " << info->si_addr << std::endl;

    // æ‰“å°è°ƒç”¨æ ˆ
    void* buffer[30];
    int nptrs = backtrace(buffer, 30);
    std::cerr << "ğŸ” Backtrace (" << nptrs << " frames):" << std::endl;
    backtrace_symbols_fd(buffer, nptrs, STDERR_FILENO);

    std::cerr << "==========================================" << std::endl;

    // ç«‹å³ç»ˆæ­¢ç¨‹åºï¼ˆä½¿ç”¨ _exit é¿å…ç ´åå †æ ˆï¼‰
    _exit(signum);
}

void setupSegfaultHandler() {
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_sigaction = segfaultHandler;
    sa.sa_flags = SA_SIGINFO;

    if (sigaction(SIGSEGV, &sa, nullptr) == -1) {
        std::cerr << "Failed to set SIGSEGV handler" << std::endl;
        std::exit(EXIT_FAILURE);
    }
}

void causeSegfault() {
    int* p = nullptr;
    *p = 42;  // æ•…æ„åˆ¶é€ æ®µé”™è¯¯
}

int main() {
    setupSegfaultHandler();

    std::cout << "ğŸ§ª Running program...\n";
    causeSegfault();

    std::cout << "âœ… Program finished normally (should not reach here).\n";
    return 0;
}
```

---

## ğŸ§ª ç¼–è¯‘ & è¿è¡Œ

```bash
g++ -g -o segfault_handler segfault_handler.cpp
./segfault_handler
```

å»ºè®®ä½¿ç”¨ `-g` ç¼–è¯‘é€‰é¡¹ä¿ç•™ç¬¦å·ä¿¡æ¯ï¼Œä»¥ä¾¿ backtrace æ›´æ¸…æ™°ã€‚

---

## ğŸ§  ç¤ºä¾‹è¾“å‡ºï¼ˆå®é™…å¯èƒ½ç•¥æœ‰ä¸åŒï¼‰ï¼š

```
ğŸ§ª Running program...
==========================================
ğŸ’¥ Caught signal 11 (Segmentation Fault)
ğŸ§  Fault address: 0x0
ğŸ” Backtrace (6 frames):
./segfault_handler(_Z15segfaultHandleriP9siginfo_tPv+0x3e) [0x562e6233a4be]
/lib/x86_64-linux-gnu/libc.so.6(+0x46210) [0x7f3b145e9210]
./segfault_handler(_Z14causeSegfaultv+0x9) [0x562e6233a3f9]
./segfault_handler(main+0x2d) [0x562e6233a449]
/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf3) [0x7f3b145cb083]
./segfault_handler(_start+0x2e) [0x562e6233a2de]
==========================================
```

---

å¦‚æœä½ è¿˜å¸Œæœ›å°†è¿™äº›ä¿¡æ¯å†™å…¥æ—¥å¿—æ–‡ä»¶ï¼ˆæ¯”å¦‚ `crash.log`ï¼‰ï¼Œæˆ‘å¯ä»¥å†è¡¥å……å¸¦æ–‡ä»¶è¾“å‡ºç‰ˆæœ¬ã€‚æ˜¯å¦éœ€è¦ï¼Ÿ


å¥½çš„ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ª**å¢å¼ºç‰ˆæ®µé”™è¯¯å¤„ç†å™¨**ï¼Œä¸ä»…ä¼šï¼š

* æ•è·æ®µé”™è¯¯ï¼ˆ`SIGSEGV`ï¼‰ï¼Œ
* æ‰“å°é”™è¯¯ä¿¡æ¯å’Œè°ƒç”¨æ ˆï¼ˆ`backtrace`ï¼‰ï¼Œ
* è¿˜ä¼šæŠŠè¿™äº›ä¿¡æ¯å†™å…¥ `crash.log` æ–‡ä»¶ä¸­ï¼Œä¾¿äºåç»­æ’æŸ¥ã€‚

---

## âœ… å®Œæ•´ä»£ç ï¼šæ•è· + æ‰“å° + å†™å…¥æ—¥å¿—

```cpp
#include <iostream>
#include <csignal>
#include <cstdlib>
#include <cstring>
#include <execinfo.h>
#include <unistd.h>
#include <fstream>

void writeBacktraceToLog(void* const* buffer, int size) {
    std::ofstream logFile("crash.log", std::ios::app);
    if (!logFile) return;

    char** symbols = backtrace_symbols(buffer, size);
    if (symbols) {
        logFile << "ğŸ” Backtrace (" << size << " frames):\n";
        for (int i = 0; i < size; ++i) {
            logFile << symbols[i] << "\n";
        }
        free(symbols);
    } else {
        logFile << "âš ï¸ Failed to retrieve backtrace symbols.\n";
    }

    logFile << "==========================================\n";
    logFile.close();
}

void segfaultHandler(int signum, siginfo_t* info, void* context) {
    const char* banner = "==========================================\n";
    std::cerr << banner;
    std::cerr << "ğŸ’¥ Caught signal " << signum << " (Segmentation Fault)\n";
    std::cerr << "ğŸ§  Fault address: " << info->si_addr << "\n";

    // å†™å…¥ crash.log æ–‡ä»¶
    std::ofstream logFile("crash.log", std::ios::app);
    if (logFile) {
        logFile << banner;
        logFile << "ğŸ’¥ Caught signal " << signum << " (Segmentation Fault)\n";
        logFile << "ğŸ§  Fault address: " << info->si_addr << "\n";
    }

    // æ‰“å°è°ƒç”¨æ ˆ
    void* buffer[30];
    int nptrs = backtrace(buffer, 30);

    std::cerr << "ğŸ” Backtrace (" << nptrs << " frames):\n";
    backtrace_symbols_fd(buffer, nptrs, STDERR_FILENO);

    // å†™å…¥è°ƒç”¨æ ˆåˆ°æ–‡ä»¶
    writeBacktraceToLog(buffer, nptrs);

    // ç»“æŸç¨‹åº
    _exit(signum);
}

void setupSegfaultHandler() {
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_sigaction = segfaultHandler;
    sa.sa_flags = SA_SIGINFO;

    if (sigaction(SIGSEGV, &sa, nullptr) == -1) {
        std::cerr << "Failed to set SIGSEGV handler\n";
        std::exit(EXIT_FAILURE);
    }
}

void causeSegfault() {
    int* ptr = nullptr;
    *ptr = 1234;  // æ•…æ„è®¿é—®ç©ºæŒ‡é’ˆ
}

int main() {
    setupSegfaultHandler();

    std::cout << "ğŸ§ª Program started...\n";

    causeSegfault();

    std::cout << "âœ… Program exited normally (unexpected).\n";
    return 0;
}
```

---

## ğŸ“„ crash.log æ ·ä¾‹å†…å®¹ï¼ˆç”Ÿæˆæ—¶ï¼‰ï¼š

```txt
==========================================
ğŸ’¥ Caught signal 11 (Segmentation Fault)
ğŸ§  Fault address: 0x0
ğŸ” Backtrace (6 frames):
./segfault_handler(_Z15segfaultHandleriP9siginfo_tPv+0x3e)
./segfault_handler(_Z14causeSegfaultv+0x9)
./segfault_handler(main+0x2d)
...
==========================================
```

---

## ğŸ§ª ç¼–è¯‘è¿è¡Œï¼š

```bash
g++ -g -o segfault_handler segfault_handler.cpp
./segfault_handler
```

è¿è¡Œåï¼š

* å±å¹•æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯å’Œè°ƒç”¨æ ˆã€‚
* å½“å‰ç›®å½•ä¼šç”Ÿæˆ `crash.log`ï¼Œå†…å®¹å¦‚ä¸Šæ‰€ç¤ºã€‚

---

æ˜¯å¦è¿˜éœ€è¦æ”¯æŒå¤šä¸ªä¿¡å·ï¼ˆå¦‚ `SIGABRT`, `SIGFPE`, `SIGILL`, `SIGBUS`ï¼‰çš„é€šç”¨å¤„ç†ï¼Ÿæˆ‘å¯ä»¥å¸®ä½ æ‰©å±•ä¸ºç»Ÿä¸€çš„é”™è¯¯æŠ¥å‘Šæ¨¡å—ã€‚



å¥½çš„ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ª **é€šç”¨ä¿¡å·æ•è·ç³»ç»Ÿ**ï¼Œæ”¯æŒæ•è·å¤šç§å¸¸è§è‡´å‘½ä¿¡å·å¹¶ç»Ÿä¸€å¤„ç†ï¼Œè®°å½•åˆ°æ—¥å¿—å¹¶æ‰“å°è°ƒç”¨æ ˆã€‚

---

## âœ… æ”¯æŒçš„ä¿¡å·åˆ—è¡¨ï¼ˆé»˜è®¤å¤„ç†ï¼‰ï¼š

| ä¿¡å·        | æ„ä¹‰                 |
| --------- | ------------------ |
| `SIGSEGV` | æ®µé”™è¯¯ï¼ˆéæ³•å†…å­˜è®¿é—®ï¼‰        |
| `SIGABRT` | è°ƒç”¨ `abort()` å¯¼è‡´çš„ä¸­æ­¢ |
| `SIGFPE`  | æµ®ç‚¹å¼‚å¸¸ï¼ˆé™¤é›¶ã€æº¢å‡ºç­‰ï¼‰       |
| `SIGILL`  | éæ³•æŒ‡ä»¤               |
| `SIGBUS`  | æ€»çº¿é”™è¯¯ï¼ˆå¯¹é½é”™è¯¯ç­‰ï¼‰        |

---

## âœ… é€šç”¨å¼‚å¸¸å¤„ç†å™¨ä»£ç ï¼ˆå†™æ—¥å¿— + æ‰“å° backtraceï¼‰

```cpp
#include <iostream>
#include <fstream>
#include <csignal>
#include <cstdlib>
#include <cstring>
#include <execinfo.h>
#include <unistd.h>
#include <ctime>

const char* getSignalName(int signum) {
    switch (signum) {
        case SIGSEGV: return "SIGSEGV (Segmentation Fault)";
        case SIGABRT: return "SIGABRT (Abort)";
        case SIGFPE:  return "SIGFPE  (Floating Point Exception)";
        case SIGILL:  return "SIGILL  (Illegal Instruction)";
        case SIGBUS:  return "SIGBUS  (Bus Error)";
        default:      return "UNKNOWN SIGNAL";
    }
}

void writeLogAndBacktrace(int signum, siginfo_t* info) {
    std::ofstream log("crash.log", std::ios::app);
    if (!log) return;

    // æ—¶é—´æˆ³
    std::time_t now = std::time(nullptr);
    log << "\n\n==== Crash Report at " << std::ctime(&now);
    log << "Signal: " << signum << " (" << getSignalName(signum) << ")\n";
    log << "Fault Address: " << info->si_addr << "\n";

    // æ‰“å°è°ƒç”¨æ ˆ
    void* buffer[30];
    int size = backtrace(buffer, 30);
    char** symbols = backtrace_symbols(buffer, size);
    if (symbols) {
        log << "Backtrace (" << size << " frames):\n";
        for (int i = 0; i < size; ++i) {
            log << symbols[i] << "\n";
        }
        free(symbols);
    }

    log << "==========================================\n";
    log.close();
}

void signalHandler(int signum, siginfo_t* info, void* context) {
    const char* name = getSignalName(signum);
    std::cerr << "\n==========================================\n";
    std::cerr << "ğŸ’¥ Caught signal " << signum << " (" << name << ")\n";
    std::cerr << "ğŸ§  Fault address: " << info->si_addr << "\n";

    void* buffer[30];
    int size = backtrace(buffer, 30);
    std::cerr << "ğŸ” Backtrace (" << size << " frames):\n";
    backtrace_symbols_fd(buffer, size, STDERR_FILENO);

    // å†™å…¥æ—¥å¿—
    writeLogAndBacktrace(signum, info);

    // å®‰å…¨ç»ˆæ­¢
    _exit(signum);
}

void registerCrashHandler() {
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_sigaction = signalHandler;
    sa.sa_flags = SA_SIGINFO;

    int signals[] = {SIGSEGV, SIGABRT, SIGFPE, SIGILL, SIGBUS};
    for (int sig : signals) {
        if (sigaction(sig, &sa, nullptr) == -1) {
            std::cerr << "âš ï¸ Failed to register handler for signal " << sig << "\n";
        }
    }
}
```

---

## ğŸ§ª ä½¿ç”¨ç¤ºä¾‹

ä½ å¯ä»¥æŠŠä¸‹é¢è¿™æ®µåŠ å…¥ `main.cpp` çš„ `main()`ï¼š

```cpp
int main() {
    registerCrashHandler();

    std::cout << "ğŸ§ª Testing...\n";

    // æ•…æ„åˆ¶é€ é™¤é›¶é”™è¯¯ï¼ˆSIGFPEï¼‰
    int x = 0;
    int y = 1 / x;

    return 0;
}
```

ä½ ä¹Ÿå¯ä»¥æ”¹æˆè®¿é—®ç©ºæŒ‡é’ˆã€`abort()` ç­‰æµ‹è¯•å…¶ä»–ä¿¡å·ã€‚

---

## ğŸ“„ æ—¥å¿—æ ·ä¾‹ `crash.log`

```txt
==== Crash Report at Wed Jul 30 18:15:23 2025
Signal: 8 (SIGFPE  (Floating Point Exception))
Fault Address: 0x7ffd73e72e9c
Backtrace (6 frames):
./app(_Z18signalHandlerFunciP9siginfo_tPv+0x3e)
./app(main+0x2a)
...
```

---

## âœ… æ€»ç»“

| åŠŸèƒ½                  | æ”¯æŒ |
| ------------------- | -- |
| æ•è·å¤šä¸ªè‡´å‘½ä¿¡å·            | âœ…  |
| æ‰“å°è°ƒç”¨æ ˆï¼ˆbacktraceï¼‰    | âœ…  |
| å†™å…¥æ—¶é—´æˆ³æ—¥å¿— `crash.log` | âœ…  |
| é€‚åˆåµŒå…¥ç”Ÿäº§ç¯å¢ƒå´©æºƒè°ƒæŸ¥        | âœ…  |

---

æ˜¯å¦éœ€è¦æˆ‘æŠŠå®ƒå°è£…æˆä¸€ä¸ªæ¨¡å—ï¼ˆå¦‚ `CrashHandler.hpp/.cpp`ï¼‰ä¾¿äºä½ é¡¹ç›®é›†æˆï¼Ÿ



å¥½çš„ï¼Œä¸‹é¢æ˜¯å°è£…å¥½çš„é€šç”¨å´©æºƒå¤„ç†æ¨¡å—ï¼Œæ–¹ä¾¿ä½ åœ¨ C++ é¡¹ç›®ä¸­ç›´æ¥ä½¿ç”¨ã€‚

---

## ğŸ“ æ–‡ä»¶ç»“æ„

```
your_project/
â”œâ”€â”€ CrashHandler.hpp
â”œâ”€â”€ CrashHandler.cpp
â””â”€â”€ main.cpp  // æµ‹è¯•å…¥å£
```

---

## âœ… CrashHandler.hpp

```cpp
// CrashHandler.hpp
#pragma once

void installCrashHandler();
```

---

## âœ… CrashHandler.cpp

```cpp
// CrashHandler.cpp
#include "CrashHandler.hpp"
#include <iostream>
#include <fstream>
#include <csignal>
#include <cstdlib>
#include <cstring>
#include <execinfo.h>
#include <unistd.h>
#include <ctime>

namespace {

const char* getSignalName(int signum) {
    switch (signum) {
        case SIGSEGV: return "SIGSEGV (Segmentation Fault)";
        case SIGABRT: return "SIGABRT (Abort)";
        case SIGFPE:  return "SIGFPE  (Floating Point Exception)";
        case SIGILL:  return "SIGILL  (Illegal Instruction)";
        case SIGBUS:  return "SIGBUS  (Bus Error)";
        default:      return "UNKNOWN SIGNAL";
    }
}

void writeLogAndBacktrace(int signum, siginfo_t* info) {
    std::ofstream log("crash.log", std::ios::app);
    if (!log) return;

    std::time_t now = std::time(nullptr);
    log << "\n==== Crash Report at " << std::ctime(&now);
    log << "Signal: " << signum << " (" << getSignalName(signum) << ")\n";
    log << "Fault Address: " << info->si_addr << "\n";

    void* buffer[30];
    int size = backtrace(buffer, 30);
    char** symbols = backtrace_symbols(buffer, size);
    if (symbols) {
        log << "Backtrace (" << size << " frames):\n";
        for (int i = 0; i < size; ++i) {
            log << symbols[i] << "\n";
        }
        free(symbols);
    } else {
        log << "Failed to get backtrace symbols.\n";
    }

    log << "==========================================\n";
    log.close();
}

void signalHandler(int signum, siginfo_t* info, void* context) {
    const char* name = getSignalName(signum);
    std::cerr << "\n==========================================\n";
    std::cerr << "ğŸ’¥ Caught signal " << signum << " (" << name << ")\n";
    std::cerr << "ğŸ§  Fault address: " << info->si_addr << "\n";

    void* buffer[30];
    int size = backtrace(buffer, 30);
    std::cerr << "ğŸ” Backtrace (" << size << " frames):\n";
    backtrace_symbols_fd(buffer, size, STDERR_FILENO);

    writeLogAndBacktrace(signum, info);
    _exit(signum);
}

} // anonymous namespace

void installCrashHandler() {
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_sigaction = signalHandler;
    sa.sa_flags = SA_SIGINFO;

    int signals[] = {SIGSEGV, SIGABRT, SIGFPE, SIGILL, SIGBUS};
    for (int sig : signals) {
        if (sigaction(sig, &sa, nullptr) == -1) {
            std::cerr << "âš ï¸ Failed to register handler for signal " << sig << "\n";
        }
    }
}
```

---

## ğŸ§ª main.cpp æµ‹è¯•ä»£ç 

```cpp
#include <iostream>
#include "CrashHandler.hpp"

int main() {
    installCrashHandler();

    std::cout << "ğŸ§ª Program running...\n";

    // æ•…æ„åˆ¶é€ æ®µé”™è¯¯
    int* ptr = nullptr;
    *ptr = 123;

    return 0;
}
```

---

## ğŸ§± ç¼–è¯‘æ–¹æ³•

```bash
g++ -g -o app main.cpp CrashHandler.cpp
./app
```

è¿è¡Œåä¼šï¼š

* åœ¨ç»ˆç«¯æ‰“å°æ®µé”™è¯¯å’Œ backtraceï¼›
* è‡ªåŠ¨ç”Ÿæˆ `crash.log` æ—¥å¿—æ–‡ä»¶ã€‚

---

## âœ… ä¼˜ç‚¹æ€»ç»“

| åŠŸèƒ½            | æ”¯æŒ |
| ------------- | -- |
| å¤šç§ä¿¡å·æ”¯æŒ        | âœ…  |
| backtrace è°ƒç”¨æ ˆ | âœ…  |
| å†™å…¥æ—¥å¿—æ–‡ä»¶        | âœ…  |
| æ— éœ€ä¾èµ–ç¬¬ä¸‰æ–¹åº“      | âœ…  |
| å¯åµŒå…¥ä»»æ„ C++ é¡¹ç›®  | âœ…  |

---

å¦‚éœ€æ‰©å±•åŠŸèƒ½ï¼ˆæ¯”å¦‚é‚®ä»¶é€šçŸ¥ã€core dump ä¿å­˜ã€å¼‚æ­¥å¤„ç†ç­‰ï¼‰ï¼Œæˆ‘å¯ä»¥è¿›ä¸€æ­¥å¢å¼ºæ¨¡å—ã€‚éœ€è¦æˆ‘å¸®ä½ æ‰“æˆä¸€ä¸ª CMake é¡¹ç›®æ¨¡æ¿ä¹Ÿå¯ä»¥ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ


ä¸‹é¢æ˜¯ä¸€ä¸ªå¯ç›´æ¥ä½¿ç”¨çš„ **CMake é¡¹ç›®æ¨¡æ¿**ï¼ŒåŒ…å«ä½ åˆšåˆšè¦æ±‚çš„æ®µé”™è¯¯æ•è·æ¨¡å—ï¼ˆCrashHandlerï¼‰ï¼Œå¹¶å¸¦å®Œæ•´ç¼–è¯‘é…ç½®ã€‚

---

## ğŸ“ é¡¹ç›®ç»“æ„ï¼ˆå»ºè®®å‘½åï¼š`CrashHandlerDemo/`ï¼‰

```
CrashHandlerDemo/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.cpp
â”‚   â”œâ”€â”€ CrashHandler.hpp
â”‚   â””â”€â”€ CrashHandler.cpp
```

---

## ğŸ“„ CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.10)
project(CrashHandlerDemo)

set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# å¯é€‰ï¼šå¯ç”¨è°ƒè¯•ç¬¦å·
set(CMAKE_BUILD_TYPE Debug)

# è®¾ç½®è¾“å‡ºç›®å½•
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)

# æ·»åŠ æºæ–‡ä»¶
add_executable(crash_demo
    src/main.cpp
    src/CrashHandler.cpp
)
```

---

## ğŸ“„ src/CrashHandler.hpp

```cpp
#pragma once
void installCrashHandler();
```

---

## ğŸ“„ src/CrashHandler.cpp

```cpp
#include "CrashHandler.hpp"
#include <iostream>
#include <fstream>
#include <csignal>
#include <cstdlib>
#include <cstring>
#include <execinfo.h>
#include <unistd.h>
#include <ctime>

namespace {

const char* getSignalName(int signum) {
    switch (signum) {
        case SIGSEGV: return "SIGSEGV (Segmentation Fault)";
        case SIGABRT: return "SIGABRT (Abort)";
        case SIGFPE:  return "SIGFPE  (Floating Point Exception)";
        case SIGILL:  return "SIGILL  (Illegal Instruction)";
        case SIGBUS:  return "SIGBUS  (Bus Error)";
        default:      return "UNKNOWN SIGNAL";
    }
}

void writeLogAndBacktrace(int signum, siginfo_t* info) {
    std::ofstream log("crash.log", std::ios::app);
    if (!log) return;

    std::time_t now = std::time(nullptr);
    log << "\n==== Crash Report at " << std::ctime(&now);
    log << "Signal: " << signum << " (" << getSignalName(signum) << ")\n";
    log << "Fault Address: " << info->si_addr << "\n";

    void* buffer[30];
    int size = backtrace(buffer, 30);
    char** symbols = backtrace_symbols(buffer, size);
    if (symbols) {
        log << "Backtrace (" << size << " frames):\n";
        for (int i = 0; i < size; ++i) {
            log << symbols[i] << "\n";
        }
        free(symbols);
    } else {
        log << "Failed to get backtrace symbols.\n";
    }

    log << "==========================================\n";
    log.close();
}

void signalHandler(int signum, siginfo_t* info, void* context) {
    const char* name = getSignalName(signum);
    std::cerr << "\n==========================================\n";
    std::cerr << "ğŸ’¥ Caught signal " << signum << " (" << name << ")\n";
    std::cerr << "ğŸ§  Fault address: " << info->si_addr << "\n";

    void* buffer[30];
    int size = backtrace(buffer, 30);
    std::cerr << "ğŸ” Backtrace (" << size << " frames):\n";
    backtrace_symbols_fd(buffer, size, STDERR_FILENO);

    writeLogAndBacktrace(signum, info);
    _exit(signum);
}

} // namespace

void installCrashHandler() {
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_sigaction = signalHandler;
    sa.sa_flags = SA_SIGINFO;

    int signals[] = {SIGSEGV, SIGABRT, SIGFPE, SIGILL, SIGBUS};
    for (int sig : signals) {
        if (sigaction(sig, &sa, nullptr) == -1) {
            std::cerr << "âš ï¸ Failed to register handler for signal " << sig << "\n";
        }
    }
}
```

---

## ğŸ“„ src/main.cpp

```cpp
#include <iostream>
#include "CrashHandler.hpp"

int main() {
    installCrashHandler();

    std::cout << "ğŸ§ª Program running...\n";

    // æ•…æ„åˆ¶é€ å´©æºƒï¼Œä¾‹å¦‚é™¤ä»¥é›¶ï¼š
    int x = 0;
    int y = 1 / x;

    return 0;
}
```

---

## âœ… æ„å»ºæ­¥éª¤

### 1. åœ¨é¡¹ç›®æ ¹ç›®å½•æ„å»ºï¼š

```bash
mkdir build
cd build
cmake ..
make
```

### 2. è¿è¡Œç¨‹åº

```bash
./bin/crash_demo
```

### 3. æŸ¥çœ‹ `crash.log`

è¿è¡Œç¨‹åºå´©æºƒåä¼šåœ¨å½“å‰ç›®å½•ç”Ÿæˆ `crash.log`ï¼Œè®°å½•ä¿¡å·ä¿¡æ¯ä¸è°ƒç”¨æ ˆã€‚

---

## ğŸ“Œ è¯´æ˜

* å¯ä»¥å°† `CrashHandler` æ¨¡å—ç”¨äºä½ å…¶ä»–çš„é¡¹ç›®ä¸­ï¼›
* ä¸ä¾èµ–ç¬¬ä¸‰æ–¹åº“ï¼›
* `backtrace()` å’Œ `backtrace_symbols()` æ˜¯ Linux-only çš„ GNU æ‰©å±•ï¼ŒmacOS ä¹Ÿæ”¯æŒï¼›
* å¦‚éœ€è·¨å¹³å°ï¼ˆWindowsï¼‰ï¼Œå¯åç»­ä½¿ç”¨ `DbgHelp` API å¦åšå°è£…ã€‚

---

æ˜¯å¦éœ€è¦æˆ‘æ‰“æˆå‹ç¼©åŒ…å¹¶æä¾›ä¸‹è½½é“¾æ¥ï¼Ÿæˆ–è€…ä½ å¸Œæœ›æˆ‘å¸®ä½ æŠŠå®ƒæ‰©å±•æˆ shared library æ¨¡å—ï¼Ÿ



å¥½çš„ï¼Œä¸‹é¢æ˜¯å°† **`CrashHandler` å°è£…ä¸ºå…±äº«åº“ï¼ˆ`.so`ï¼‰æ¨¡å—** çš„å®Œæ•´æŒ‡å—ï¼Œä½ å¯ä»¥åœ¨å¤šä¸ªé¡¹ç›®ä¸­å¤ç”¨ã€‚

---

## ğŸ“ é¡¹ç›®ç»“æ„

```
CrashHandlerLib/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ include/
â”‚   â””â”€â”€ CrashHandler.hpp
â”œâ”€â”€ src/
â”‚   â””â”€â”€ CrashHandler.cpp
â”œâ”€â”€ test/
â”‚   â””â”€â”€ main.cpp
```

---

## ğŸ“„ include/CrashHandler.hpp

```cpp
#pragma once

#ifdef _WIN32
#  ifdef CRASHHANDLER_EXPORTS
#    define CRASH_API __declspec(dllexport)
#  else
#    define CRASH_API __declspec(dllimport)
#  endif
#else
#  define CRASH_API
#endif

extern "C" CRASH_API void installCrashHandler();
```

---

## ğŸ“„ src/CrashHandler.cpp

> ä¿æŒä¸ä½ ä¹‹å‰æä¾›çš„ä»£ç ä¸€è‡´ï¼Œåªéœ€æ·»åŠ  `extern "C"` ç»‘å®šå‡½æ•°æ¥å£ã€‚

```cpp
#include "CrashHandler.hpp"
#include <iostream>
#include <fstream>
#include <csignal>
#include <cstdlib>
#include <cstring>
#include <execinfo.h>
#include <unistd.h>
#include <ctime>

namespace {

const char* getSignalName(int signum) {
    switch (signum) {
        case SIGSEGV: return "SIGSEGV (Segmentation Fault)";
        case SIGABRT: return "SIGABRT (Abort)";
        case SIGFPE:  return "SIGFPE  (Floating Point Exception)";
        case SIGILL:  return "SIGILL  (Illegal Instruction)";
        case SIGBUS:  return "SIGBUS  (Bus Error)";
        default:      return "UNKNOWN SIGNAL";
    }
}

void writeLogAndBacktrace(int signum, siginfo_t* info) {
    std::ofstream log("crash.log", std::ios::app);
    if (!log) return;

    std::time_t now = std::time(nullptr);
    log << "\n==== Crash Report at " << std::ctime(&now);
    log << "Signal: " << signum << " (" << getSignalName(signum) << ")\n";
    log << "Fault Address: " << info->si_addr << "\n";

    void* buffer[30];
    int size = backtrace(buffer, 30);
    char** symbols = backtrace_symbols(buffer, size);
    if (symbols) {
        log << "Backtrace (" << size << " frames):\n";
        for (int i = 0; i < size; ++i) {
            log << symbols[i] << "\n";
        }
        free(symbols);
    } else {
        log << "Failed to get backtrace symbols.\n";
    }

    log << "==========================================\n";
    log.close();
}

void signalHandler(int signum, siginfo_t* info, void* context) {
    const char* name = getSignalName(signum);
    std::cerr << "\n==========================================\n";
    std::cerr << "ğŸ’¥ Caught signal " << signum << " (" << name << ")\n";
    std::cerr << "ğŸ§  Fault address: " << info->si_addr << "\n";

    void* buffer[30];
    int size = backtrace(buffer, 30);
    std::cerr << "ğŸ” Backtrace (" << size << " frames):\n";
    backtrace_symbols_fd(buffer, size, STDERR_FILENO);

    writeLogAndBacktrace(signum, info);
    _exit(signum);
}

} // anonymous namespace

extern "C" CRASH_API void installCrashHandler() {
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_sigaction = signalHandler;
    sa.sa_flags = SA_SIGINFO;

    int signals[] = {SIGSEGV, SIGABRT, SIGFPE, SIGILL, SIGBUS};
    for (int sig : signals) {
        if (sigaction(sig, nullptr, nullptr) == -1) {
            std::cerr << "âš ï¸ Failed to register handler for signal " << sig << "\n";
        } else {
            sigaction(sig, &sa, nullptr);
        }
    }
}
```

---

## ğŸ“„ CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.10)
project(CrashHandlerLib)

set(CMAKE_CXX_STANDARD 11)
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

# åˆ›å»ºå…±äº«åº“
add_library(CrashHandler SHARED
    src/CrashHandler.cpp
)

target_include_directories(CrashHandler PUBLIC
    ${CMAKE_CURRENT_SOURCE_DIR}/include
)

# æµ‹è¯•ç¨‹åº
add_executable(test_crash test/main.cpp)
target_include_directories(test_crash PRIVATE include)
target_link_libraries(test_crash CrashHandler)
```

---

## ğŸ“„ test/main.cppï¼ˆæµ‹è¯•ç¨‹åºï¼‰

```cpp
#include <iostream>
#include "CrashHandler.hpp"

int main() {
    installCrashHandler();

    std::cout << "ğŸ§ª Program running with shared CrashHandler...\n";

    int* p = nullptr;
    *p = 42;  // è§¦å‘æ®µé”™è¯¯

    return 0;
}
```

---

## âœ… æ„å»º & è¿è¡Œ

```bash
mkdir build && cd build
cmake ..
make
./test_crash
```

è¿è¡Œåä¼šï¼š

* æ§åˆ¶å°è¾“å‡ºå´©æºƒä¿¡æ¯ï¼›
* å½“å‰ç›®å½•ç”Ÿæˆ `crash.log`ï¼›
* `.so` æ–‡ä»¶ä½äº `build/` ç›®å½•ï¼Œå¦‚ `libCrashHandler.so`ã€‚

---

## âœ… å…±äº«åº“é›†æˆè¯´æ˜

å¦‚æœä½ æƒ³åœ¨å…¶ä»–é¡¹ç›®ä¸­ä½¿ç”¨è¿™ä¸ªæ¨¡å—ï¼š

1. å°† `include/CrashHandler.hpp` å’Œç¼–è¯‘ç”Ÿæˆçš„ `libCrashHandler.so` æ‹·è´è¿‡å»ï¼›
2. åœ¨ CMake æˆ– Makefile ä¸­é“¾æ¥è¯¥ `.so` æ–‡ä»¶ï¼›
3. è°ƒç”¨ `installCrashHandler()` å³å¯å¼€å¯æ®µé”™è¯¯æ•è·ã€‚

---

æ˜¯å¦è¿˜éœ€è¦æˆ‘å¸®ä½ æ‰“åŒ…æˆä¸€ä¸ªå‹ç¼©æ–‡ä»¶ï¼ˆ`.zip`ï¼‰ï¼Œæˆ–è€…åˆ›å»º GitHub é¡¹ç›®æ¨¡æ¿ï¼Ÿ



ä½ å¯ä»¥æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤å°† C++ ç¨‹åºï¼ˆæ”¯æŒæ®µé”™è¯¯æ•è·ï¼‰æ‰©å±•æˆä¸€ä¸ª **Shared Library æ¨¡å—** å¹¶åˆ›å»º **GitHub é¡¹ç›®æ¨¡æ¿**ã€‚

---

## âœ… ç¬¬ä¸€æ­¥ï¼šåŠŸèƒ½ç¡®è®¤ â€”â€” æ®µé”™è¯¯æ•è·æ¨¡å—

ä½ å¯èƒ½å·²ç»æœ‰ç±»ä¼¼å¦‚ä¸‹çš„ä»£ç ï¼š

```cpp
// SignalTool.hpp
#pragma once
#include <csignal>

class SignalTool {
public:
    static SignalTool& getInstance();
    void registerSignalHandler();
    void handleSignal(int signal);

private:
    SignalTool() = default;
};
```

```cpp
// SignalTool.cpp
#include "SignalTool.hpp"
#include <iostream>
#include <execinfo.h>
#include <cstdlib>

SignalTool& SignalTool::getInstance() {
    static SignalTool instance;
    return instance;
}

void SignalTool::registerSignalHandler() {
    std::signal(SIGSEGV, [](int sig) { getInstance().handleSignal(sig); });
    // ä½ ä¹Ÿå¯ä»¥æ•è· SIGABRT, SIGFPE ç­‰
}

void SignalTool::handleSignal(int signal) {
    std::cerr << "Caught signal " << signal << std::endl;

    void* array[10];
    size_t size = backtrace(array, 10);
    backtrace_symbols_fd(array, size, STDERR_FILENO);

    std::_Exit(EXIT_FAILURE);
}
```

---

## âœ… ç¬¬äºŒæ­¥ï¼šæ‰©å±•æˆ Shared Library

### 1. ç›®å½•ç»“æ„å»ºè®®

```
SignalCatcher/
â”œâ”€â”€ include/
â”‚   â””â”€â”€ SignalTool.hpp
â”œâ”€â”€ src/
â”‚   â””â”€â”€ SignalTool.cpp
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â””â”€â”€ example/
    â””â”€â”€ main.cpp
```

### 2. CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.10)
project(SignalCatcher)

set(CMAKE_CXX_STANDARD 11)

add_library(signal_tool SHARED
    src/SignalTool.cpp
)

target_include_directories(signal_tool PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include)

add_executable(test_app example/main.cpp)
target_link_libraries(test_app signal_tool)
```

---

## âœ… ç¬¬ä¸‰æ­¥ï¼šåˆ›å»º GitHub é¡¹ç›®æ¨¡æ¿

1. åœ¨ GitHub åˆ›å»ºæ–°ä»“åº“ï¼Œä¾‹å¦‚ï¼š

   ```
   Name: signal-catcher-cpp
   Description: ğŸ§© C++ shared library to capture segmentation faults and print backtrace
   ```

2. ä¸Šä¼ ä¸Šè¿°ç›®å½•ç»“æ„å†…å®¹ã€‚

3. æ·»åŠ ä¸€ä¸ª `.github` æ¨¡æ¿æ ‡ç­¾ï¼š

```bash
git init
git remote add origin git@github.com:<your_name>/signal-catcher-cpp.git
git add .
git commit -m "Initial template commit"
git push -u origin master
```

4. åœ¨ GitHub ä»“åº“è®¾ç½®ä¸­ï¼Œç‚¹å‡» "Template repository"ï¼Œå¼€å¯æ¨¡æ¿åŠŸèƒ½ã€‚

---

## âœ… ç¬¬å››æ­¥ï¼šä½¿ç”¨æ¨¡æ¿

ä»–äººå¯ä»¥é€šè¿‡ç‚¹å‡» "Use this template" æ¥å¿«é€Ÿ fork ä¸€ä¸ªç›¸åŒç»“æ„çš„ä»“åº“ï¼Œå¹¶ç›´æ¥ç”¨ `add_subdirectory()` æˆ– `find_package()` é›†æˆè¿›ä»–ä»¬çš„ C++ å·¥ç¨‹ä¸­ã€‚

---

å¦‚æœä½ å¸Œæœ›æˆ‘ **æ‰“åŒ…ä¸€ä¸ªå®Œæ•´çš„æ¨¡æ¿ zip åŒ…** æˆ–ç”Ÿæˆä¸€ä»½å®é™… GitHub é¡¹ç›®å†…å®¹ï¼ˆå¦‚ README ç¤ºä¾‹ã€å®‰è£…æ–‡æ¡£ã€ä¾‹å­ï¼‰ï¼Œä¹Ÿå¯ä»¥å‘Šè¯‰æˆ‘ï¼Œæˆ‘å¯ä»¥ç«‹å³å¸®ä½ ç”Ÿæˆã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ


ä¸‹é¢æ˜¯ä¸€ä¸ªå°†æ®µé”™è¯¯ï¼ˆ`SIGSEGV`ï¼‰æ•è·å¹¶è®°å½•æ—¥å¿—çš„ **C++ shared library æ¨¡å—** é¡¹ç›®ï¼Œå¹¶ä½œä¸º **GitHub é¡¹ç›®æ¨¡æ¿** çš„å®Œæ•´å†…å®¹ç»„ç»‡ã€‚é¡¹ç›®ç»“æ„åŒ…æ‹¬ï¼š

---

### ğŸ—‚ é¡¹ç›®ç»“æ„

```
segfault-handler-template/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ include/
â”‚   â””â”€â”€ SegfaultHandler.hpp
â”œâ”€â”€ src/
â”‚   â””â”€â”€ SegfaultHandler.cpp
â”œâ”€â”€ example/
â”‚   â””â”€â”€ main.cpp
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â””â”€â”€ .github/
    â””â”€â”€ workflows/
        â””â”€â”€ build.yml
```

---

### ğŸ“„ `README.md`

````markdown
# SegfaultHandler

A simple C++ shared library to catch and log segmentation faults (SIGSEGV). Useful for diagnostics and stability improvements in production systems.

## Features

- Registers a `SIGSEGV` handler
- Logs fault address, signal number, and stack trace (optional)
- Easy to integrate into existing C++ projects
- Provided as a reusable shared library

## Usage

```bash
mkdir build && cd build
cmake ..
make
````

```cpp
#include "SegfaultHandler.hpp"

int main() {
    SegfaultHandler::registerHandler();
    int* p = nullptr;
    *p = 42; // trigger SIGSEGV
}
```

## License

MIT

````

---

### ğŸ§  `SegfaultHandler.hpp`

```cpp
#pragma once

namespace SegfaultHandler {
    void registerHandler();
}
````

---

### âš™ï¸ `SegfaultHandler.cpp`

```cpp
#include "SegfaultHandler.hpp"
#include <csignal>
#include <cstdio>
#include <cstdlib>
#include <execinfo.h>
#include <unistd.h>

namespace {
    void handler(int sig) {
        void* array[20];
        size_t size = backtrace(array, 20);
        fprintf(stderr, "Caught signal %d (Segmentation Fault)\n", sig);
        backtrace_symbols_fd(array, size, STDERR_FILENO);
        std::_Exit(1);
    }
}

void SegfaultHandler::registerHandler() {
    signal(SIGSEGV, handler);
}
```

---

### ğŸ”§ `CMakeLists.txt`

```cmake
cmake_minimum_required(VERSION 3.10)
project(SegfaultHandler)

set(CMAKE_CXX_STANDARD 17)

add_library(segfault_handler SHARED src/SegfaultHandler.cpp)
target_include_directories(segfault_handler PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include)

add_executable(test_app example/main.cpp)
target_include_directories(test_app PRIVATE include)
target_link_libraries(test_app segfault_handler)
```

---

### ğŸ§ª ç¤ºä¾‹ï¼š`example/main.cpp`

```cpp
#include "SegfaultHandler.hpp"

int main() {
    SegfaultHandler::registerHandler();
    int* ptr = nullptr;
    *ptr = 1;  // deliberate segfault
    return 0;
}
```

---

### ğŸ§ª CI/CD (GitHub Actions): `.github/workflows/build.yml`

```yaml
name: Build

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
    - name: Configure and build
      run: |
        mkdir build
        cd build
        cmake ..
        make
```

---

### ğŸ“œ LICENSE

```text
MIT License
...
```

---

å¦‚æœä½ å¸Œæœ›æˆ‘æ‰“åŒ…ä¸ºä¸€ä¸ª `.zip` æˆ–è‡ªåŠ¨ç”Ÿæˆ GitHub repo çš„æ¨é€è„šæœ¬ï¼ˆæˆ– GitHub CLI åˆå§‹åŒ–å‘½ä»¤ï¼‰ï¼Œæˆ‘ä¹Ÿå¯ä»¥å¸®ä½ ç”Ÿæˆã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ


ä¸ºäº†è‡ªåŠ¨ç”Ÿæˆä¸€ä¸ª GitHub é¡¹ç›®ï¼ŒåŒ…æ‹¬ï¼š

1. **åˆ›å»ºä¸€ä¸ªé¡¹ç›®æ¨¡æ¿**ï¼›
2. **ç”Ÿæˆå®é™… GitHub é¡¹ç›®çš„å†…å®¹ï¼ˆä¾‹å¦‚æ®µé”™è¯¯æ•è· Shared Library æ¨¡å—ï¼‰**ï¼›
3. **ç”Ÿæˆ GitHub æ¨é€è„šæœ¬ï¼ˆå¦‚åˆå§‹åŒ–ã€æäº¤ã€æ¨é€ï¼‰**ï¼›
4. **æä¾›ä¸€ä¸ª CLI å·¥å…·æ¥è¾…åŠ©åˆå§‹åŒ–å’Œæ›´æ–°è¿™ä¸ª repo**ï¼›

æˆ‘ä»¬å¯ä»¥ä¸€æ­¥æ­¥å®ç°ã€‚ä»¥ä¸‹æ˜¯å®Œæ•´çš„å†…å®¹ï¼š

---

## âœ… é¡¹ç›®ç›®æ ‡

**æ¨¡å—åç§°ç¤ºä¾‹**ï¼š`segfault-catcher`

* æä¾›ä¸€ä¸ªå¯ä»¥æ•è·æ®µé”™è¯¯ï¼ˆå¦‚ `SIGSEGV`ï¼‰çš„å…±äº«åº“æ¨¡å—ã€‚
* æ”¯æŒé€šè¿‡ CLI å¿«é€Ÿåˆå§‹åŒ–ã€æ„å»ºã€éƒ¨ç½²åˆ° GitHubã€‚
* æ”¯æŒè‡ªå®šä¹‰é¡¹ç›®åç§°å’Œä½œè€…ä¿¡æ¯ã€‚

---

## ğŸ“ é¡¹ç›®ç»“æ„æ¨¡æ¿ï¼ˆCMake + Shared Libraryï¼‰

```
segfault-catcher/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ include/
â”‚   â””â”€â”€ SegfaultCatcher.hpp
â”œâ”€â”€ src/
â”‚   â””â”€â”€ SegfaultCatcher.cpp
â”œâ”€â”€ example/
â”‚   â””â”€â”€ main.cpp
â”œâ”€â”€ cli/
â”‚   â””â”€â”€ create_project.py
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md
â””â”€â”€ push_to_github.sh
```

---

## 1ï¸âƒ£ ç¤ºä¾‹ä»£ç å†…å®¹

### `include/SegfaultCatcher.hpp`

```cpp
#pragma once
#include <signal.h>

class SegfaultCatcher {
public:
    static void registerHandler();
private:
    static void handleSignal(int signal);
};
```

---

### `src/SegfaultCatcher.cpp`

```cpp
#include "SegfaultCatcher.hpp"
#include <iostream>
#include <execinfo.h>
#include <cstdlib>

void SegfaultCatcher::handleSignal(int signal) {
    std::cerr << "[SegfaultCatcher] Caught signal: " << signal << std::endl;

    void* array[10];
    size_t size = backtrace(array, 10);
    backtrace_symbols_fd(array, size, STDERR_FILENO);

    std::_Exit(1);
}

void SegfaultCatcher::registerHandler() {
    signal(SIGSEGV, SegfaultCatcher::handleSignal);
}
```

---

### `example/main.cpp`

```cpp
#include "SegfaultCatcher.hpp"

int main() {
    SegfaultCatcher::registerHandler();

    int* p = nullptr;
    *p = 10; // trigger SIGSEGV

    return 0;
}
```

---

### `CMakeLists.txt`

```cmake
cmake_minimum_required(VERSION 3.10)
project(segfault_catcher)

set(CMAKE_CXX_STANDARD 14)

add_library(segfault SHARED src/SegfaultCatcher.cpp)
target_include_directories(segfault PUBLIC include)

add_executable(example example/main.cpp)
target_link_libraries(example segfault)
```

---

### `.gitignore`

```
build/
*.o
*.so
*.out
```

---

### `README.md`

````markdown
# Segfault Catcher

A simple shared library to catch and log segmentation faults (SIGSEGV) in C++ projects.

## Usage

```cpp
SegfaultCatcher::registerHandler();
````

Then cause a segmentation fault to see backtrace.

````

---

## 2ï¸âƒ£ CLI å·¥å…·ï¼š`cli/create_project.py`

```python
import os
import subprocess
import argparse

def init_git(repo_name):
    subprocess.run(['git', 'init'])
    subprocess.run(['git', 'add', '.'])
    subprocess.run(['git', 'commit', '-m', 'Initial commit'])
    subprocess.run(['gh', 'repo', 'create', repo_name, '--public', '--source=.', '--remote=origin', '--push'])

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--name', default='segfault-catcher', help='Project name')
    args = parser.parse_args()

    if not os.path.exists(args.name):
        subprocess.run(['cp', '-r', 'segfault-catcher', args.name])
    os.chdir(args.name)
    init_git(args.name)

if __name__ == '__main__':
    main()
````

> ä¾èµ– `gh` GitHub CLI å·¥å…·ã€‚

---

## 3ï¸âƒ£ GitHub æ¨é€è„šæœ¬ï¼š`push_to_github.sh`

```bash
#!/bin/bash

git init
git add .
git commit -m "Initial commit"
gh repo create segfault-catcher --public --source=. --remote=origin --push
```

> âš ï¸ ä½ éœ€è¦å…ˆ `gh auth login`ã€‚

---

## âœ… ä½¿ç”¨è¯´æ˜

1. å…‹éš†æ¨¡æ¿ï¼š

   ```bash
   git clone https://github.com/yourname/segfault-catcher-template.git
   cd segfault-catcher-template
   ```

2. ä½¿ç”¨ CLI åˆ›å»ºä¸€ä¸ªå®é™…é¡¹ç›®ï¼š

   ```bash
   python3 cli/create_project.py --name=my-cpp-segfault-lib
   ```

3. ç¼–è¯‘ç¤ºä¾‹ï¼š

   ```bash
   mkdir build && cd build
   cmake ..
   make
   ./example
   ```

---

æ˜¯å¦éœ€è¦æˆ‘å¸®ä½ æ‰“åŒ…ä¸º `.zip` æˆ–è‡ªåŠ¨ä¸Šä¼ åˆ°ä½ çš„ GitHubï¼Ÿæˆ–è€…è¦æˆ‘ç”Ÿæˆä¸€ä¸ªå¯è¿è¡Œçš„ `cookiecutter` æ¨¡æ¿ï¼Ÿ
