```bash
memset 对 C++ 对象是未定义行为

std::map<std::string, std::string> 是一个 C++ 非平凡类型，它内部有指针、分配器、链表节点等复杂资源。

memset(&mDataInfo, 0, sizeof(...)) 会把 内部指针也清零，但不会调用 map 的析构函数，之前 map 里存放的内容就直接 泄漏 掉了。

“清空”整个DataInfo
重新赋值一个新的对象
mDataInfo = DataInfo{};
这样会调用 std::map 的析构（释放内容），然后构造一个新的空对象。


C: 用 memset 只能用于 POD（Plain Old Data）（C 风格 struct）
如果结构体里含有 C++ 对象（比如 std::map、std::string），千万不要用 memset。



std::vector<int> v{1,2,3};
memset(&v, 0, sizeof(v));  // 🚨 未定义行为
v 内部的 指针成员 被清零，但 new 出来的那段动态数组还留在堆上，没人能 free → 内存泄漏。
此时再调用 v.push_back()、v.size() 等操作，几乎肯定崩溃（因为内部状态被破坏）。

释放元素但保留 capacity:  v.clear();   (不会释放底层内存，capacity 还在)

彻底释放所有内存:
v.clear();
v.shrink_to_fit();  // C++11 起支持，通常能把 buffer 释放掉

交换空 vector 技巧（最干净）:
std::vector<int>().swap(v);  



struct DataInfo{
    vector<int> v;
};
memset(&mDataInfo, 0, sizeof(...))

如果 mDataInfo 里面含有 非 POD 类型（比如 std::vector、std::string 等），你这样做会直接把它们内部的指针和状态清零，相当于把对象破坏掉（未定义行为，UB）。

一旦你再对这个对象做操作（如 v.push_back），程序大概率会崩溃。

如果只是要“重置”一个含有 std::vector 的结构体，有两种安全写法：

✅ 方法 1：用默认构造覆盖
mDataInfo = {};
这会把 mDataInfo 重置为默认构造状态，内部的 vector 会被安全地析构并重建。
    相当于重新赋值一个 全新的临时对象 给 mDataInfo
    这个新对象的 v 是 空 vector（size=0，capacity=0）。
    原来 v 占用的内存会被释放（相当于彻底清空，capacity 也回收）。
    每次执行都像“换了个新对象”。
    👉 效果：完全 reset，内存也回收。

✅ 方法 2：用 swap 技巧
mDataInfo tmp;          // 临时默认对象
mDataInfo.swap(tmp);   // 交换后 mDataInfo 就是空的
这样可以保证对象安全清理。
    std::vector<int>().swap(mDataInfo.v);
    这相当于把一个新的空 vector 交换进来。
    和 mDataInfo{} 的效果类似：size=0, capacity=0。
    原有内存会被释放。
    👉 效果：清空数据，同时回收内存。


    mDataInfo.v.clear();  // 只清空 size，保留 capacity
    v 的元素被销毁，但 capacity 不变。

    如果下次 push_back 很多元素，不需要重新分配，效率更高。

    内存不会马上回收，适合 重复使用、数据量大且稳定 的场景。

    👉 效果：清空数据，但保留 vector 的 buffer，提高效率。


如果数据量小（例如 v 里每次只有几十个结果），用 DataInfo{} 直接 reset 是完全没问题的，效率不会受明显影响。

只有在 数据量特别大且复用频繁（比如几万、几十万元素，每秒多次调用）时，才需要用 clear() 来避免频繁释放/分配内存。













1. mDataInfo = DataInfo{};

这里显式构造了一个 临时对象 DataInfo{}，

然后调用赋值运算符 operator= 把临时对象的内容赋给 mDataInfo

如果 DataInfo 是 聚合类型/普通 struct，那么就是逐成员赋值。

如果你自己写了赋值运算符，那么会调用你写的那个。

2. mDataInfo = {};

这是 列表初始化 的简写形式。

编译器会尝试用默认构造 {} 初始化一个临时对象（跟上面类似）。

对于大部分 struct/class，这等价于 mDataInfo = DataInfo{}。

✅ 相同点

对于 POD 类型（普通 struct，没有构造/析构/运算符重载），两者完全等价。

都会把 mDataInfo 的成员清零（数值型 → 0，指针 → nullptr，浮点型 → 0.0）。

⚠️ 不同点

如果 DataInfo 有 构造函数/赋值运算符重载：

= DataInfo{} → 会调用构造函数，再调用赋值运算符。

= {} → 直接走列表初始化规则，可能调用的构造函数不同（尤其是 explicit 的情况）。

📌 总结

大多数情况下（POD struct / 简单 struct）：
mDataInfo = {}; 和 mDataInfo = DataInfo{}; 等价，都会把内容清零。

有构造函数/运算符重载时：
可能会走不同的路径，推荐写 DataInfo{}，更清晰。




📊 对照表：结构体初始化方式对比
写法	适用场景	初始化效果	是否安全	备注
memset(&obj, 0, sizeof(obj));	C/C++ 都可用	把整个内存区域逐字节置零	⚠️ 仅对 POD 类型安全（基本类型、数组、enum 等）	不会调用构造函数，若有 std::string、std::vector 等非 POD 类型，会破坏内部结构导致内存泄漏或崩溃
Type obj = {0};	C 和 C++	仅保证第一个成员置 0，其余成员也会自动清零（对 POD 类型）。等价于 全部成员清零	✅ 安全（POD 类型）	C 风格，很多老代码常用；在 C++ 里更推荐 {}
Type obj{};	C++11 及以上	全部成员初始化为 0 或默认构造（对类成员会调用默认构造函数）	✅ 最安全	推荐 C++ 用法，等价于 memset 0，但支持非 POD 类型，比如 std::vector 会被正确初始化为空






memcp

memcpy 结构体含 std::vector 成员

memcpy(output, &mDataInfo, sizeof(DataInfo));

❌ 不安全！std::vector 内部有指针、大小、capacity 等成员，直接拷贝会导致 浅拷贝，后续释放时可能 double-free 或内存泄漏。
memcpy 只能用于 POD 类型，std::vector/std::map 不是 POD



拷贝 DataInfo

如果要把 mDataInfo 的数据拷贝到另一个对象 output，直接赋值：

DataInfo output = mDataInfo;  // 安全拷贝

或者，如果 output 是指针：

*output = mDataInfo;  // 安全拷贝，vector 会深拷贝
✅ std::vector 会自动深拷贝，不会破坏内存。

```
